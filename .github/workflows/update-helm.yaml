name: Update Helm Image Tag

on:
  release:
    types: [published] # Trigger only when a release is published

jobs:
  update-helm:
    runs-on: ubuntu-latest
    env:
      GIT_AUTHOR_NAME: github-actions
      GIT_AUTHOR_EMAIL: github-actions@github.com
      GIT_COMMITTER_NAME: github-actions
      GIT_COMMITTER_EMAIL: github-actions@github.com
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.MACHINE_USER_TOKEN }}
          fetch-depth: 0 # Fetch all history for proper branch detection

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/download/v4.44.1/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Make scripts executable
        run: chmod +x ./scripts/generate_commit_message.sh ./scripts/generate_pr_body.sh

      - name: Debug Event Information
        run: |
          echo "Event name: ${{ github.event_name }}" # Should always be 'release'
          echo "Event action: ${{ github.event.action }}" # Should always be 'published'
          echo "Release tag: ${{ github.event.release.tag_name }}"
          echo "Release name: ${{ github.event.release.name }}"
          echo "Release draft: ${{ github.event.release.draft }}"
          echo "Release prerelease: ${{ github.event.release.prerelease }}"

      - name: Determine tag and environment from Release
        id: vars
        run: |
          RAW_TAG="${{ github.event.release.tag_name }}"
          echo "Processing published release event for tag $RAW_TAG"

          # Determine environment based on tag format and prerelease flag
          # Production: tag starts with 'v', is NOT a prerelease, and not 'vstg-'
          # Staging: tag starts with 'vstg-' OR is a prerelease
          if [[ "$RAW_TAG" == v* && "${{ github.event.release.prerelease }}" == "false" && "$RAW_TAG" != vstg-* ]]; then
            ENV="prod"
            # Extract semantic version from tag (remove 'v' prefix)
            SEMANTIC_VERSION="${RAW_TAG#v}"
            # Use the semantic version as the deploy tag for prod
            DEPLOY_TAG="$SEMANTIC_VERSION"
            # Ensure it's a clean X.Y.Z format
            if ! [[ "$DEPLOY_TAG" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
               echo "::error::Invalid production tag format '$RAW_TAG'. Expected 'vX.Y.Z'."
               exit 1
            fi
            GIT_HASH="" # Not relevant for prod tag
          elif [[ "$RAW_TAG" == vstg-* || "${{ github.event.release.prerelease }}" == "true" ]]; then
            ENV="stg"
            # For staging, extract the git hash from the tag (format vstg-X.Y.Z-hash)
            if [[ "$RAW_TAG" =~ vstg-([0-9]+\.[0-9]+\.[0-9]+)-([a-f0-9]+) ]]; then
              # Extract base semantic version and hash
              BASE_SEMVER="${BASH_REMATCH[1]}"
              GIT_HASH="${BASH_REMATCH[2]}"
              # Construct semantic version with -stg suffix and deploy tag with stg- prefix
              SEMANTIC_VERSION="${BASE_SEMVER}-stg" # e.g., 1.2.3-stg
              DEPLOY_TAG="stg-${GIT_HASH}" # Use stg-<hash> as the deploy tag
              echo "git_hash=$GIT_HASH" >> $GITHUB_ENV
            else
              echo "::error::Invalid staging tag format '$RAW_TAG'. Expected 'vstg-X.Y.Z-<hash>'."
              exit 1
            fi
          else
            echo "::error::Could not determine environment from tag '$RAW_TAG' and prerelease status (${{ github.event.release.prerelease }})."
            exit 1
          fi

          echo "Determined environment: $ENV"
          echo "Determined semantic version: $SEMANTIC_VERSION"
          echo "Determined deploy tag: $DEPLOY_TAG"
          echo "Determined git hash: $GIT_HASH"

          # Set outputs
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "raw_version=$RAW_TAG" >> $GITHUB_OUTPUT # Keep original tag for reference
          echo "semantic_version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
          echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT
          echo "git_hash=$GIT_HASH" >> $GITHUB_OUTPUT

      - name: Update Helm values with new image tag (Idempotent)
        id: update_helm
        run: |
          ENV="${{ steps.vars.outputs.env }}"
          DEPLOY_TAG="${{ steps.vars.outputs.deploy_tag }}"
          SEMANTIC_VERSION="${{ steps.vars.outputs.semantic_version }}" # For Chart.yaml update

          echo "::group::Environment and Target Tag Information"
          echo "Environment: $ENV"
          echo "Target Deploy Tag: $DEPLOY_TAG"
          echo "Target Semantic Version (for Chart.yaml if prod): $SEMANTIC_VERSION"
          echo "::endgroup::"

          # Determine values file path
          if [[ "$ENV" == "prod" ]]; then
            VALUES_FILE="config/helm/values-prod.yaml"
            CHART_FILE="charts/fastapi/Chart.yaml"
          elif [[ "$ENV" == "stg" ]]; then
            VALUES_FILE="config/helm/values-stg.yaml"
            CHART_FILE="" # No Chart.yaml update for staging
          else
            echo "::error::Invalid environment '$ENV' determined."
            exit 1
          fi

          # Check if values file exists
          if [ ! -f "$VALUES_FILE" ]; then
            echo "::error::Values file $VALUES_FILE does not exist"
            ls -la config/helm/
            exit 1
          fi
          echo "✅ Values file exists: $VALUES_FILE"

          # --- Idempotency Check ---
          echo "::group::Checking Current Tag Values"
          CURRENT_BACKEND_TAG=$(yq e '.backend.tag' "$VALUES_FILE" || echo "ERROR")
          CURRENT_FRONTEND_TAG=$(yq e '.frontend.tag' "$VALUES_FILE" || echo "ERROR")

          if [[ "$CURRENT_BACKEND_TAG" == "ERROR" || "$CURRENT_FRONTEND_TAG" == "ERROR" ]]; then
            echo "::error::Failed to read current tag values from $VALUES_FILE"
            exit 1
          fi
          echo "Current backend tag: $CURRENT_BACKEND_TAG"
          echo "Current frontend tag: $CURRENT_FRONTEND_TAG"

          # Check Chart.yaml version for prod
          CURRENT_CHART_VERSION=""
          CURRENT_APP_VERSION=""
          if [[ "$ENV" == "prod" && -n "$CHART_FILE" && -f "$CHART_FILE" ]]; then
             CURRENT_CHART_VERSION=$(yq e '.version' "$CHART_FILE" || echo "ERROR")
             CURRENT_APP_VERSION=$(yq e '.appVersion' "$CHART_FILE" || echo "ERROR")
             echo "Current Chart.yaml version: $CURRENT_CHART_VERSION"
             echo "Current Chart.yaml appVersion: $CURRENT_APP_VERSION"
             if [[ "$CURRENT_CHART_VERSION" == "ERROR" || "$CURRENT_APP_VERSION" == "ERROR" ]]; then
               echo "::error::Failed to read current Chart.yaml versions"
               exit 1
             fi
          elif [[ "$ENV" == "prod" ]]; then
             echo "::warning::Chart.yaml file not found or not specified for prod. Skipping version check."
          fi
          echo "::endgroup::"

          # Compare current tags/versions with the target deploy tag/semantic version
          NEEDS_UPDATE="false"
          if [[ "$CURRENT_BACKEND_TAG" != "$DEPLOY_TAG" || "$CURRENT_FRONTEND_TAG" != "$DEPLOY_TAG" ]]; then
            NEEDS_UPDATE="true"
            echo "Values file needs update: Tags mismatch."
          fi

          # Also check Chart.yaml for prod
          if [[ "$ENV" == "prod" && -n "$CHART_FILE" && -f "$CHART_FILE" ]]; then
            # Ensure SEMANTIC_VERSION is clean X.Y.Z for comparison
            if [[ "$SEMANTIC_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              if [[ "$CURRENT_CHART_VERSION" != "$SEMANTIC_VERSION" || "$CURRENT_APP_VERSION" != "$SEMANTIC_VERSION" ]]; then
                NEEDS_UPDATE="true"
                echo "Chart.yaml needs update: Versions mismatch."
              fi
            else
               echo "::warning::Cannot compare Chart.yaml version as target semantic version '$SEMANTIC_VERSION' is not in X.Y.Z format."
            fi
          fi

          if [[ "$NEEDS_UPDATE" == "false" ]]; then
            echo "✅ Helm values are already up-to-date with target tag '$DEPLOY_TAG'. No changes needed."
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 0 # Exit successfully, no further steps needed
          fi
          # --- End Idempotency Check ---

          echo "::group::Updating Image Tags and Chart Version"
          echo "Updating values file: $VALUES_FILE"
          echo "Updating backend tag: $CURRENT_BACKEND_TAG -> $DEPLOY_TAG"
          yq e -i ".backend.tag = \"$DEPLOY_TAG\"" "$VALUES_FILE"
          echo "Updating frontend tag: $CURRENT_FRONTEND_TAG -> $DEPLOY_TAG"
          yq e -i ".frontend.tag = \"$DEPLOY_TAG\"" "$VALUES_FILE"

          # Update Chart.yaml version for production if needed
          if [[ "$ENV" == "prod" && -n "$CHART_FILE" && -f "$CHART_FILE" ]]; then
            # Ensure SEMANTIC_VERSION is clean X.Y.Z
            if [[ "$SEMANTIC_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              if [[ "$CURRENT_CHART_VERSION" != "$SEMANTIC_VERSION" || "$CURRENT_APP_VERSION" != "$SEMANTIC_VERSION" ]]; then
                 echo "Updating Chart.yaml: $CHART_FILE"
                 echo "Updating version: $CURRENT_CHART_VERSION -> $SEMANTIC_VERSION"
                 yq e -i ".version = \"$SEMANTIC_VERSION\"" "$CHART_FILE"
                 echo "Updating appVersion: $CURRENT_APP_VERSION -> $SEMANTIC_VERSION"
                 yq e -i ".appVersion = \"$SEMANTIC_VERSION\"" "$CHART_FILE"
              fi
            else
              echo "::warning::Not updating Chart.yaml version as semantic version '$SEMANTIC_VERSION' is not in X.Y.Z format"
            fi
          fi
          echo "::endgroup::"

          echo "::group::Verification after Update"
          NEW_BACKEND_TAG=$(yq e '.backend.tag' "$VALUES_FILE" || echo "ERROR")
          NEW_FRONTEND_TAG=$(yq e '.frontend.tag' "$VALUES_FILE" || echo "ERROR")

          if [[ "$NEW_BACKEND_TAG" == "ERROR" || "$NEW_FRONTEND_TAG" == "ERROR" ]]; then
             echo "::error::Failed to read tags after update!"
             exit 1
          fi
          if [[ "$NEW_BACKEND_TAG" != "$DEPLOY_TAG" || "$NEW_FRONTEND_TAG" != "$DEPLOY_TAG" ]]; then
            echo "::error::Tag verification failed after update!"
            echo "Expected: $DEPLOY_TAG"
            echo "Got: backend=$NEW_BACKEND_TAG, frontend=$NEW_FRONTEND_TAG"
            exit 1
          fi
          echo "✅ Tags successfully updated and verified in $VALUES_FILE"

          # Verify Chart.yaml for prod
          if [[ "$ENV" == "prod" && -n "$CHART_FILE" && -f "$CHART_FILE" ]]; then
             if [[ "$SEMANTIC_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
               NEW_CHART_VERSION=$(yq e '.version' "$CHART_FILE" || echo "ERROR")
               NEW_APP_VERSION=$(yq e '.appVersion' "$CHART_FILE" || echo "ERROR")
               if [[ "$NEW_CHART_VERSION" == "ERROR" || "$NEW_APP_VERSION" == "ERROR" ]]; then
                  echo "::error::Failed to read Chart.yaml versions after update!"
                  exit 1
               fi
               if [[ "$NEW_CHART_VERSION" != "$SEMANTIC_VERSION" || "$NEW_APP_VERSION" != "$SEMANTIC_VERSION" ]]; then
                 echo "::error::Chart.yaml version verification failed after update!"
                 echo "Expected: $SEMANTIC_VERSION"
                 echo "Got: version=$NEW_CHART_VERSION, appVersion=$NEW_APP_VERSION"
                 exit 1
               fi
               echo "✅ Chart.yaml versions successfully updated and verified"
             fi
          fi
          echo "::endgroup::"

          # Set outputs for use in later steps
          echo "updated=true" >> $GITHUB_OUTPUT
          echo "old_backend_tag=$CURRENT_BACKEND_TAG" >> $GITHUB_OUTPUT
          echo "old_frontend_tag=$CURRENT_FRONTEND_TAG" >> $GITHUB_OUTPUT
          # Keep deploy_tag output as it's used in commit message/PR title
          echo "deploy_tag=$DEPLOY_TAG" >> $GITHUB_OUTPUT

      - name: Commit changes
        id: commit
        # Only run if the update step indicated changes were made
        if: steps.update_helm.outputs.updated == 'true'
        env: # Pass necessary variables to the script
          ENV: ${{ steps.vars.outputs.env }}
          DEPLOY_TAG: ${{ steps.update_helm.outputs.deploy_tag }}
          RAW_VERSION: ${{ steps.vars.outputs.raw_version }}
          OLD_BACKEND_TAG: ${{ steps.update_helm.outputs.old_backend_tag }}
          OLD_FRONTEND_TAG: ${{ steps.update_helm.outputs.old_frontend_tag }}
          SEMANTIC_VERSION: ${{ steps.vars.outputs.semantic_version }}
        run: |
          echo "::group::Git Configuration"
          git config --global user.name "${{ env.GIT_AUTHOR_NAME }}"
          git config --global user.email "${{ env.GIT_AUTHOR_EMAIL }}"
          echo "::endgroup::"

          DEFAULT_BRANCH="main"
          echo "Default branch: $DEFAULT_BRANCH"

          echo "::group::Branch Creation"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          # Use deploy_tag for branch name safety
          TAG_SAFE=$(echo "$DEPLOY_TAG" | sed 's/[^a-zA-Z0-9]/-/g')
          BRANCH_NAME="helm-update-${TAG_SAFE}-${TIMESTAMP}"
          echo "Creating new branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"
          echo "::endgroup::"

          echo "::group::Git Status and Changes"
          git status
          # Add specific files that might have changed
          git add config/helm/values-*.yaml charts/fastapi/Chart.yaml || echo "No files to add, continuing..."

          # Check if there are staged changes before committing
          if ! git diff --staged --quiet; then
            echo "Staged changes detected, proceeding with commit."
            echo "Generating commit message..."
            # Generate commit message using script and commit using -F - (read from stdin)
            if ./scripts/generate_commit_message.sh | git commit -F -; then
              echo "✅ Changes committed successfully"
              if git push origin "$BRANCH_NAME"; then
                echo "✅ Changes pushed successfully"
                echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
                echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT
                echo "has_changes=true" >> $GITHUB_OUTPUT
              else
                echo "::error::Failed to push changes to remote"
                exit 1
              fi
            else
              echo "::error::git commit command failed"
              exit 1
            fi
          else
            # This case should ideally not be reached due to the 'updated=true' check
            echo "No staged changes detected. Skipping commit."
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::" # End Git Status and Changes group

      - name: Prepare PR Body
        if: steps.commit.outputs.has_changes == 'true'
        env: # Pass necessary variables to the script
          ENV: ${{ steps.vars.outputs.env }}
          RAW_VERSION: ${{ steps.vars.outputs.raw_version }}
          DEPLOY_TAG: ${{ steps.update_helm.outputs.deploy_tag }}
          OLD_BACKEND_TAG: ${{ steps.update_helm.outputs.old_backend_tag }}
          OLD_FRONTEND_TAG: ${{ steps.update_helm.outputs.old_frontend_tag }}
          SEMANTIC_VERSION: ${{ steps.vars.outputs.semantic_version }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: ./scripts/generate_pr_body.sh

      - name: Create Pull Request
        # Only run if the commit step indicated changes were pushed
        if: steps.commit.outputs.has_changes == 'true'
        id: create_pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.MACHINE_USER_TOKEN }}
          # Commit message is handled by the previous step
          # commit-message: "chore(helm): update image tags for ${{ steps.vars.outputs.env }} to ${{ steps.update_helm.outputs.deploy_tag }}"
          branch: ${{ steps.commit.outputs.branch_name }}
          base: ${{ steps.commit.outputs.default_branch }}
          title: "chore(helm): update image tags for ${{ steps.vars.outputs.env }} to ${{ steps.update_helm.outputs.deploy_tag }}" # Concise title
          # Use the prepared PR body file
          body-path: pr_body.md
          labels: |
            automated-pr
            helm-update
            env/${{ steps.vars.outputs.env }}
          delete-branch: true # Delete the branch after merge/close

      - name: Auto-merge Pull Request
        # Only run if PR was created
        if: steps.create_pr.outputs.pull-request-number
        run: |
          PR_NUMBER=${{ steps.create_pr.outputs.pull-request-number }}
          echo "Created PR #${PR_NUMBER}"

          # Install GitHub CLI if not already cached
          if ! command -v gh &> /dev/null; then
            echo "Installing GitHub CLI..."
            # Use recommended installation method
            type -p curl >/dev/null || (sudo apt update && sudo apt install curl -y)
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
            && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
            && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
            && sudo apt update \
            && sudo apt install gh -y
          else
             echo "GitHub CLI already installed."
          fi

          # Authenticate with GitHub CLI
          echo "${{ secrets.MACHINE_USER_TOKEN }}" | gh auth login --with-token

          # Enable auto-merge for the PR
          echo "Enabling auto-merge for PR #${PR_NUMBER}"
          # Use --merge flag for merge commit strategy, add --delete-branch here too
          gh pr merge "${PR_NUMBER}" --auto --merge --delete-branch

          echo "Auto-merge enabled for PR #${PR_NUMBER}"

      # This step is no longer needed as app-release-trigger handles release creation
      # - name: Create GitHub Release (if not triggered by release)
      #   ...
